<!DOCTYPE html>
<html>
<head>
   <title>JMockit - Tutorial - Mocking</title>
   <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
   <link rel="stylesheet" type="text/css" href="../prettify.css"/>
   <link rel="shortcut icon" type="image/x-icon" href="../favicon.ico"/>
   <script type="text/javascript" src="../highlight.pack.js"></script>
   <script type="text/javascript">hljs.initHighlightingOnLoad()</script>
</head>
<body>
<h1 class="header">
   <a href="../index.html">JMockit</a>
   <span>An automated testing toolkit for Java</span>
   <span class="navigation">
      <a href="EnterpriseApplications.html"><img src="go-previous.png" title="Previous chapter"></a>
      <a href="Faking.html"><img src="go-next.png" title="Next chapter"></a>
      <a href="../tutorial.html"><img src="go-home.png" title="Contents"></a>
   </span>
</h1>
<h1 id="top">
   <a href="#">Mocking</a>
</h1>
<table align="center" width="100%"><tr>
   <td>
      <ol class="contents">
         <li><a href="#mocked">Mocked types and instances</a></li>
         <li><a href="#expectation">Expectations</a></li>
         <li><a href="#model">The <em>record-replay-verify</em> model</a></li>
         <li><a href="#tested">Instantiation and injection of tested classes</a></li>
         <li><a href="#results">Recording results for an expectation</a></li>
         <li>
            <a href="#argumentMatching">Flexible matching of argument values</a>
            <ol>
               <li><a href="#matcherFields">Using the "any" fields</a></li>
               <li><a href="#withMethods">Using the "with" methods</a></li>
            </ol>
         </li>
         <li><a href="#constraints">Specifying invocation count constraints</a></li>
         <li>
            <a href="#verification">Explicit verification</a>
            <ol>
               <li><a href="#verificationInOrder">Verification in order</a></li>
               <li><a href="#fullVerification">Full verification</a></li>
            </ol>
         </li>
         <li><a href="#delegates">Delegates: specifying custom results</a></li>
      </ol>
   </td>
   <td>
      <ol class="contents">
         <li value="10">
            <a href="#withCapture">Capturing invocation arguments for verification</a>
            <ol>
               <li><a href="#singleInvocationCapture">Capturing arguments from a single invocation</a></li>
               <li><a href="#multipleInvocationCapture">Capturing arguments from multiple invocations</a></li>
               <li><a href="#capturingNewInstances">Capturing new instances</a></li>
            </ol>
         </li>
         <li>
            <a href="#cascading">Cascading mocks</a>
            <ol>
               <li><a href="#staticFactories">Cascading static factory methods</a></li>
               <li><a href="#fluent">Cascading self-returning methods</a></li>
            </ol>
         </li>
         <li>
            <a href="#instanceMatching">Matching invocations to specific instances</a>
            <ol>
               <li><a href="#injectable">Injectable mocked instances</a></li>
               <li><a href="#multipleMockedInstances">Declaring multiple mocked instances</a></li>
               <li><a href="#futureInstancesByConstructor">Instances created with a given constructor</a></li>
            </ol>
         </li>
         <li><a href="#partial">Partial mocking</a></li>
         <li><a href="#capturing">Mocking unspecified implementation classes</a></li>
      </ol>
   </td>
</tr></table>
<div align="center"><img src="MockingAPI.png"></div>
<p>
   In the JMockit library, the <strong>Expectations</strong> API provides rich support for the use of <em>mocking</em> in automated
   developer tests.
   When mocking is used, a test focuses on the behavior of the code under test, as expressed through its <em>interactions</em> with other
   types it depends upon.
   Mocking is typically used in the construction of <em>isolated</em> unit tests, where a <em>unit</em> under test is exercised in isolation
   from the implementation of other units it depends on.
   Typically, a unit of behavior is a single class, but it's also fine to consider a whole set of strongly-related classes as a single unit
   for the purposes of unit testing (as is usually the case when we have a central public class with one or more helper classes, possibly
   package-private); in general, individual methods should not be regarded as separate units on their own.
</p>
<p>
   <em>Strict</em> unit testing, however, is not a recommended approach; one should not attempt to mock every single dependency.
   Mocking is best used in moderation; whenever possible, favor integration tests over isolated unit tests.
   This said, mocking is occasionally also useful in the creation of integration tests, when some particular dependency cannot have its real
   implementation easily used, or when attempting to create tests for corner cases where a well-placed mocked interaction can greatly
   facilitate the test.
</p>

<h2 id="mocked">
   <a href="#mocked">Mocked types and instances</a>
</h2>
<p>
   Mocking provides a mechanism for isolating a class to be tested from (some of) its dependencies.
   We specify which particular dependencies are to be mocked by declaring suitable <em>mock fields</em> and/or <em>mock parameters</em> in a
   test class; mock fields are declared as annotated instance fields of the test class, while mock parameters are declared as annotated
   parameters of a test method.
   The type of the mock field or parameter can be any kind of <em>reference</em> type: an <code>interface</code>, a <code>class</code>
   (including <code>abstract</code> and <code>final</code> ones), an annotation, or an <code>enum</code>.
</p>
<p>
   The following example test skeleton (using Java 8 and JUnit 4) serves as a basic illustration for the declaration of mock fields and mock
   parameters, as well as the way in which they are typically used in test code.
</p>
<pre><code>@Mocked Dependency mockInstance; // holds a mocked instance automatically created for use in each test

@Test
public void doBusinessOperationXyz(@Mocked AnotherDependency anotherMock) {
   ...
   new Expectations() {{ // an "expectation block"
      ...
      // Record an expectation, with a given value to be returned:
      <strong>mockInstance</strong>.mockedMethod(...); <var>result</var> = 123;
      ...
   }};
   ...
   // Call the code under test.
   ...
   new Verifications() {{ // a "verification block"
      // Verifies an expected invocation:
      <strong>anotherMock</strong>.save(<var>any</var>); <var>times</var> = 1;
   }};
   ...
}
</code></pre>
<p>
   For a mock parameter declared in a test method, an instance of the declared type will be automatically created by JMockit and passed by
   the JUnit/TestNG test runner when it executes the test method; therefore, the parameter value will never be <code>null</code>.
   For a mock field, an instance of the declared type will be automatically created and assigned to the field (provided it's not
   <code>final</code>).
</p>
<p>
   There are three different mocking annotations we can use when declaring mock fields and parameters:
   <code class="annotation">@Mocked</code>, which will mock all methods and constructors on all existing and <em>future</em> instances of a
   mocked class (for the duration of the tests using it); <code class="annotation">@Injectable</code>, which constrains mocking to the
   instance methods of a single mocked instance; and <code class="annotation">@Capturing</code>, which extends mocking to the classes
   implementing a mocked interface, or the subclasses extending a mocked class.
</p>
<p>
   The mocked instances created by JMockit can be used normally in test code (for the recording and verification of expectations), and/or
   passed to the code under test. Or they may simply go unused.
   Differently from other mocking APIs, these <em>mocked</em> objects don't have to be the ones used by the code under test when it calls
   instance methods on its dependencies.
   When using <code class="annotation">@Mocked</code> or <code class="annotation">@Capturing</code> (but not when using
   <code class="annotation">@Injectable</code>), JMockit does not care on which particular object a mocked instance method is called.
   This allows the transparent mocking of instances created directly inside code under test, when said code invokes constructors on brand
   new instances using the <code>new</code> operator; the classes instantiated must be covered by mocked types declared in test code, that's
   all.
</p>

<h2 id="expectation">
   <a href="#expectation">Expectations</a>
</h2>
<p>
   An <em>expectation</em> represents a set of invocations to a specific mocked method/constructor that is relevant for a given test.
   An expectation may cover multiple different invocations to the same method or constructor, but it doesn't have to cover <em>all</em> such
   invocations that occur during the execution of the test.
   Whether a particular invocation matches a given expectation or not will depend not only on the method/constructor signature but also on
   runtime aspects such as the instance on which the method is invoked, argument values, and/or the number of invocations already matched.
   Therefore, several types of matching <em>constraints</em> can (optionally) be specified for a given expectation.
</p>
<p>
   When we have one or more invocation parameters involved, an exact argument value may be specified for each parameter.
   For example, the value <code>"test string"</code> could be specified for a <code>String</code> parameter, causing the expectation to
   match only those invocations with this exact value in the corresponding parameter.
   As we will see later, instead of specifying exact argument values, we can specify more relaxed constraints which will match whole sets of
   different argument values.
</p>
<p>
   The example below shows an expectation for <code>Dependency#someMethod(int, String)</code>, which will match an invocation to this method
   with the exact argument values as specified.
   Notice that the expectation itself is specified through an isolated invocation to the mocked method.
   There are no special API methods involved, as is common in other mocking APIs.
   This invocation, however, does not count as one of the "real" invocations we are interested in testing.
   It's only there so that the expectation can be specified.
</p>
<pre><code>@Test
public void doBusinessOperationXyz(@Mocked Dependency mockInstance) {
   ...
   new Expectations() {{
      ...
      // An expectation for an instance method:
      <strong>mockInstance.someMethod(1, "test");</strong> <var>result</var> = "mocked";
      ...
   }};

   // A call to code under test occurs here, leading to mock invocations
   // that may or may not match specified expectations.
}
</code></pre>
<p>
   We will see more about expectations later, after we understand the differences between <em>recording</em>, <em>replaying</em>, and
   <em>verifying</em> invocations.
</p>

<h2 id="model">
   <a href="#model">The <em>record-replay-verify</em> model</a>
</h2>
<p>
   Any developer test can be divided in at least three separate execution <em>phases</em>.
   The phases execute sequentially, one at a time, as demonstrated below.
</p>
<pre><code>@Test
public void someTestMethod() {
   // 1. Preparation: whatever is required before the code under test can be exercised.
   ...
   // 2. The code under test is exercised, usually by calling a public method.
   ...
   // 3. Verification: whatever needs to be checked to make sure the code exercised by
   //    the test did its job.
   ...
}
</code></pre>
<p>
   First, we have a preparation phase, where objects and data items needed for the test are created or obtained from somewhere else.
   Then, code under test is exercised.
   Finally, the results from exercising the tested code are compared with the expected results.
</p>
<p>
   This model of three phases is also known as the <em>Arrange, Act, Assert syntax</em>, or "AAA" for short.
   Different words, but the meaning is the same.
</p>
<p>
   In the context of behavior-based testing with mocked types (and their mocked instances), we can identify the following alternative
   phases, which are directly related to the three previously described conventional testing phases:
</p>
<ol>
   <li>
      The <strong><em>record</em></strong> phase, during which invocations can be <em>recorded</em>.
      This happens during test preparation, <em>before</em> the invocations we want to test are executed.
   </li>
   <li>
      The <strong><em>replay</em></strong> phase, during which the mock invocations of interest have a chance to be executed, as the code
      under test is exercised.
      The invocations to mocked methods/constructors previously recorded will now be <em>replayed</em>.
      Often there isn't a one-to-one mapping between invocations recorded and replayed, though.
   </li>
   <li>
      The <strong><em>verify</em></strong> phase, during which invocations can be <em>verified</em> to have occurred as expected.
      This happens during test verification, <em>after</em> the invocations under test had a chance to be executed.
   </li>
</ol>
<p>
   Behavior-based tests written with JMockit will typically fit the following templates:
</p>
<pre><code>import mockit.*;
... other imports ...

public class SomeTest
{
   // Zero or more "mock fields" common to all test methods in the class:
   @Mocked Collaborator mockCollaborator;
   @Mocked AnotherDependency anotherDependency;
   ...

   @Test
   public void testWithRecordAndReplayOnly(mock parameters) {
      // Preparation code not specific to JMockit, if any.

      <strong>new Expectations()</strong> {{ // an "expectation block"
         // One or more invocations to mocked types, causing expectations to be <strong>recorded</strong>.
         // Invocations to non-mocked types are also allowed anywhere inside this block
         // (though not recommended).
      }};

      // Code under test is exercised.

      // Verification code (JUnit/TestNG assertions), if any.
   }

   @Test
   public void testWithReplayAndVerifyOnly(mock parameters) {
      // Preparation code not specific to JMockit, if any.

      // Code under test is exercised.

      <strong>new Verifications()</strong> {{ // a "verification block"
         // One or more invocations to mocked types, causing expectations to be <strong>verified</strong>.
         // Invocations to non-mocked types are also allowed anywhere inside this block
         // (though not recommended).
      }};

      // Additional verification code, if any, either here or before the verification block.
   }

   @Test
   public void testWithBothRecordAndVerify(mock parameters) {
      // Preparation code not specific to JMockit, if any.

      <strong>new Expectations()</strong> {{
         // One or more invocations to mocked types, causing expectations to be recorded.
      }};

      // Code under test is exercised.

      <strong>new VerificationsInOrder()</strong> {{ // an <em>ordered</em> verification block
         // One or more invocations to mocked types, causing expectations to be verified
         // in the specified order.
      }};

      // Additional verification code, if any, either here or before the verification block.
   }
}
</code></pre>
<p>
   There are other variations to the above templates, but the essence is that the expectation blocks belong to the <em>record</em> phase
   and come before the code under test is exercised, while the verification blocks belong to the <em>verify</em> phase.
   A test method can contain any number of expectation blocks, including none. The same is true for verification blocks.
</p>

<h2 id="tested">
   <a href="#tested">Instantiation and injection of tested classes</a>
</h2>
<p>
   A non-<code>final</code> instance field annotated as <code class="annotation">@Tested</code> in the test class will be considered for
   automatic instantiation and injection, just before the execution of a test method.
   If at this time the field still holds the <code>null</code> reference, an instance will be created using a suitable constructor of the
   tested class, while making sure its internal dependencies get properly injected (when applicable).
</p>
<p>
   In order to inject <em>mocked</em> instances into the tested object, the test class must also contain one or more mock fields or mock
   parameters declared to be <strong><code class="annotation">@Injectable</code></strong>.
   Mock fields/parameters annotated only with <code class="annotation">@Mocked</code> or <code class="annotation">@Capturing</code> are
   <em>not</em> considered for injection.
   On the other hand, not all injectable fields/parameters need to have <em>mockable</em> types; they can also have <em>primitive</em> or
   <em>array</em> types.
   The following example test class will demonstrate.
</p>
<pre><code>public class SomeTest
{
   @Tested CodeUnderTest tested;
   @Injectable Dependency dep1;
   @Injectable AnotherDependency dep2;
   @Injectable int someIntegralProperty = 123;

   @Test
   public void someTestMethod(@Injectable("true") boolean flag, @Injectable("Mary") String name) {
      // Record expectations on mocked types, if needed.

      tested.exerciseCodeUnderTest();

      // Verify expectations on mocked types, if required.
   }
}
</code></pre>
<p>
   Note that a non-mockable injectable field/parameter must have a value explicitly specified for it, otherwise the default value would be
   used.
   In the case of an injectable <em>field</em>, the value can simply be assigned to the field.
   Alternatively, it can be provided in the "<code>value</code>" attribute of <code class="annotation">@Injectable</code>, which is the
   only way to specify the value in the case of an injectable test method parameter.
</p>
<p>
   Two forms of injection are supported: <em>constructor</em> injection and <em>field</em> injection.
   In the first case, the tested class must have a constructor which can be satisfied by the injectables and/or tested values made available
   in the test class.
   Note that for a given test, the set of available injectable/tested values consists of the set of injectable/tested fields declared as
   instances fields of the test class <em>plus</em> the set of injectable/tested parameters declared in the test method; therefore,
   different tests in the same test class can provide different sets of values to be injected into the same tested object.
</p>
<p>
   Once the tested class is initialized with the chosen constructor, its remaining uninitialized non-<code>final</code> instance fields are
   considered for injection.
   For each such field to be injected, an injectable/tested field of the same type is searched in the test class.
   If only one is found, its current value is read and then stored in the injected field.
   If there is more than one, the injected field name is used to select between the injectable/tested fields of same type.
</p>

<h2 id="results">
   <a href="#results">Recording results for an expectation</a>
</h2>
<p>
   For a given method with non-<code>void</code> return type, a return value can be recorded with an assignment to the
   <code><var>result</var></code> field.
   When the method gets called in the replay phase, the specified return value will be returned to the caller.
   The assignment to <code><var>result</var></code> should appear right after the invocation that identifies the recorded expectation,
   inside an expectation block.
</p>
<p>
   If the test instead needs an exception or error to be thrown when the method is invoked, then the <code><var>result</var></code> field
   can still be used: simply assign the desired throwable instance to it.
   Note that the recording of exceptions/errors to be thrown is applicable to mocked methods (of any return type) as well as to mocked
   constructors.
</p>
<p>
   Multiple <em>consecutive</em> values to return can be recorded for an expectation, by calling the <code>returns(v1, v2, ...)</code>
   method.
   Alternatively, the same can be achieved by assigning the <code><var>result</var></code> field with a <em>list</em> or <em>array</em>
   containing the consecutive values.
</p>
<p>
   The following example test records both types of results for the methods of a mocked <code class="type">DependencyAbc</code> class, to
   be used when they are invoked from <code class="type">ClassUnderTest</code>.
   Lets say the implementation of the class under test goes like this:
</p>
<pre><code>public class ClassUnderTest
{
   private final DependencyAbc abc = <strong>new DependencyAbc()</strong>;

   public void doSomething() {
(1)   int n = <strong>abc.intReturningMethod()</strong>;

      for (int i = 0; i < n; i++) {
         String s;

         try {
(2)         s = <strong>abc.stringReturningMethod()</strong>;
         }
         catch (SomeCheckedException e) {
            // somehow handle the exception
         }

         // do some other stuff
      }
   }
}
</code></pre>
<p>
   A possible test for the <code>doSomething()</code> method could exercise the case where <code class="type">SomeCheckedException</code>
   gets thrown, after an arbitrary number of successful iterations.
   Assuming that we want to record a set of expectations for the interaction between these two classes, we might write the test below.
</p>
<pre><code>@Tested ClassUnderTest cut;

@Test
public void doSomethingHandlesSomeCheckedException(@Mocked DependencyAbc abc) throws Exception {
   new Expectations() {{
(1)   abc.intReturningMethod(); <strong><var>result</var> = 3</strong>;

(2)   abc.stringReturningMethod();
      <strong>returns("str1", "str2")</strong>;
      <strong><var>result</var> = new SomeCheckedException()</strong>;
   }};

   <var>cut</var>.doSomething();
}
</code></pre>
<p>
   This test records two expectations.
   The first one specifies that <code>intReturningMethod()</code> will return <code>3</code> when called.
   The second specifies a sequence of three consecutive results for <code>stringReturningMethod()</code>, where the last result happens to
   be an instance of the desired exception, allowing the test to achieve its goal.
</p>

<h2 id="argumentMatching">
   <a href="#argumentMatching">Flexible matching of argument values</a>
</h2>
<p>
   In both the <em>record</em> and <em>verify</em> phases, an invocation to a mocked method or constructor identifies an expectation.
   If the method/constructor has one or more parameters, then a recorded/verified expectation like <code>doSomething(1, "s", true);</code>
   will only match an invocation in the <em>replay</em> phase if it has <em>equal</em> argument values.
   For arguments that are regular objects (not primitives or arrays), the <code>equals(Object)</code> method is used for equality checking.
   For parameters of array type, equality checking extends to individual elements; therefore, two different array instances having the same
   length in each dimension and equal corresponding elements are considered equal.
</p>
<p>
   In a given test, we often don't know exactly what those argument values will be, or they simply aren't essential for what is being
   tested.
   So, to allow a recorded or verified invocation to match a whole set of replayed invocations with different argument
   values, we can specify flexible <em>argument matching constraints</em> instead of actual argument values.
   This is done by using <code>anyXyz</code> <em>fields</em> and/or <code>withXyz(...)</code> methods.
   The "any" fields and "with" methods are all defined in <code class="type">mockit.Invocations</code>, which is the base class for all the
   expectation/verification classes used in tests; therefore, they can be used in expectation as well as verification blocks.
</p>

<h3 id="matcherFields">
   <a href="#matcherFields">Using the "any" fields</a>
</h3>
<p>
   The most common argument matching constraint tends also to be the <em>least</em> restrictive one: to match invocations with <em>any</em>
   value for a given parameter (of the proper parameter type, of course).
   For such cases we have a whole set of special <em>argument matching fields</em>, one for each primitive type (and the corresponding
   wrapper class), one for strings, and a "universal" one of type <code>Object</code>.
   The test below demonstrates some uses.
</p>
<pre><code>@Tested CodeUnderTest cut;

@Test
public void someTestMethod(@Mocked DependencyAbc abc) {
   DataItem item = new DataItem(...);

   new Expectations() {{
      // Will match "voidMethod(String, List)" invocations where the first argument is
      // any string and the second any list.
      abc.voidMethod(<strong><var>anyString</var>, (List&lt;?>) <var>any</var></strong>);
   }};

   <var>cut</var>.doSomething(item);

   new Verifications() {{
      // Matches invocations to the specified method with any value of type long or Long.
      abc.anotherVoidMethod(<var>anyLong</var>);
   }};
}
</code></pre>
<p>
   Uses of "<code>any</code>" fields must appear at the actual argument positions in the invocation statement, never before.
   You can still have regular argument values for other parameters in the same invocation, though.
   For more details, see the API documentation.
</p>

<h3 id="withMethods">
   <a href="#withMethods">Using the "with" methods</a>
</h3>
<p>
   When recording or verifying an expectation, calls to the <code>withXyz(...)</code> methods can occur for any subset of the arguments
   passed in the invocation.
   They can be freely mixed with regular argument-passing (using literal values, local variables, etc.).
   The only requirement is that such calls appear inside the recorded/verified invocation statement, rather than before it.
   It's not possible, for example, to first assign the result of a call to <code>withNotEqual(val)</code> to a local variable and then use
   the variable in the invocation statement.
   An example test using some of the "with" methods is shown below.
</p>
<pre><code>@Test
public void someTestMethod(@Mocked DependencyAbc abc) {
   DataItem item = new DataItem(...);

   new Expectations() {{
      // Will match "voidMethod(String, List)" invocations with the first argument
      // equal to "str" and the second not null.
      abc.voidMethod(<strong>"str", (List&lt;?>) withNotNull()</strong>);

      // Will match invocations to DependencyAbc#stringReturningMethod(DataItem, String)
      // with the first argument pointing to "item" and the second one containing "xyz".
      abc.stringReturningMethod(<strong>withSameInstance(item), withSubstring("xyz")</strong>);
   }};

   <var>cut</var>.doSomething(item);

   new Verifications() {{
      // Matches invocations to the specified method with any long-valued argument.
      abc.anotherVoidMethod(<strong>withAny(1L)</strong>);
   }};
}
</code></pre>
<p>
   There are more "with" methods than shown above. Use your IDE's code completion, and consult the API documentation for more details.
</p>
<p>
   Besides the several predefined argument matching constraints available in the API, JMockit allows the user to provide custom constraints,
   through the <code>with(Delegate)</code> method.
</p>

<h2 id="constraints">
   <a href="#constraints">Specifying invocation count constraints</a>
</h2>
<p>
   So far, we saw that besides an associated method or constructor, an expectation can have invocation results and argument matchers.
   Given that code under test can call the same method or constructor multiple times with different or identical arguments, we sometimes
   need a way to account for all those separate invocations.
</p>
<p>
   The number of invocations expected and/or allowed to match a given expectation can be specified through <em>invocation count
   constraints</em>.
   The mocking API provides three special fields just for that: <code><var>times</var></code>, <code><var>minTimes</var></code>, and
   <code><var>maxTimes</var></code>.
   These fields can be used either when recording or when verifying expectations.
   In either case, the method or constructor associated with the expectation will be constrained to receive a number of invocations that
   falls in the specified range.
   Any invocations less or more than the expected lower or upper limit, respectively, and the test execution will automatically fail.
   Lets see some example tests.
</p>
<pre><code>@Tested CodeUnderTest cut;

@Test
public void someTestMethod(@Mocked DependencyAbc abc) {
   new Expectations() {{
      // By default, at least one invocation is expected, i.e. "minTimes = 1":
      new DependencyAbc();

      // At least two invocations are expected:
      abc.voidMethod(); <strong><var>minTimes</var> = 2;</strong>

      // 1 to 5 invocations are expected:
      abc.stringReturningMethod(); <strong><var>minTimes</var> = 1; <var>maxTimes</var> = 5;</strong>
   }};

   <var>cut</var>.doSomething();
}

@Test
public void someOtherTestMethod(@Mocked DependencyAbc abc) {
   <var>cut</var>.doSomething();

   new Verifications() {{
      // Verifies that zero or one invocations occurred, with the specified argument value:
      abc.anotherVoidMethod(3); <strong><var>maxTimes</var> = 1;</strong>

      // Verifies the occurrence of at least one invocation with the specified arguments:
      DependencyAbc.someStaticMethod("test", false); // "minTimes = 1" is implied
   }};
}
</code></pre>
<p>
   Unlike the <code><var>result</var></code> field, each of these three fields can be specified at most once for a given expectation.
   Any non-negative integer value is valid for any of the invocation count constraints.
   If <code><var>times</var> = <strong>0</strong></code> or <code><var>maxTimes</var> = <strong>0</strong></code> is specified, the first
   invocation matching the expectation to occur during replay (if any) will cause the test to fail.
</p>

<h2 id="verification">
   <a href="#verification">Explicit verification</a>
</h2>
<p>
   Besides specifying invocation count constraints on recorded expectations, we can also verify matching invocations explicitly in a
   <em>verification</em> block, <em>after</em> the call to the code under test.
</p>
<p>
   Inside a "<code>new Verifications() {...}</code>" block we can use the same API that's available in a
   "<code>new Expectations() {...}</code>" block, with the exception of methods and fields used to record return values
   and thrown exceptions/errors.
   That is, we can freely use the <code>anyXyz</code> fields, the <code>withXyz(...)</code> argument matching methods, and the
   <code><var>times</var></code>, <code><var>minTimes</var></code>, and <code><var>maxTimes</var></code> invocation count constraint fields.
   An example test follows.
</p>
<pre><code>@Test
public void verifyInvocationsExplicitlyAtEndOfTest(@Mocked Dependency mock) {
   // Nothing recorded here, though it could be.

   // Inside tested code:
   Dependency dependency = new Dependency();
   dependency.doSomething(123, true, "abc-xyz");

   // Verifies that Dependency#doSomething(int, boolean, String) was called at least once,
   // with arguments that obey the specified constraints:
   <strong>new Verifications() {{ mock.doSomething(<var>anyInt</var>, true, withPrefix("abc")); }};</strong>
}
</code></pre>
<p>
   Note that, by default, a verification checks that <em>at least one</em> matching invocation occurred during replay.
   When we need to verify an exact number of invocations (including <code>1</code>), the
   <code><var>times</var> = n</code> constraint must be specified.
</p>

<h3 id="verificationInOrder">
   <a href="#verificationInOrder">Verification in order</a>
</h3>
<p>
   Regular verification blocks created with the <code class="type">Verifications</code> class are <em>unordered</em>.
   The actual relative order in which <code>aMethod()</code> and <code>anotherMethod()</code> were called during the replay phase is not
   verified, but only that each method was executed at least once.
   If you want to verify the relative order of invocations, then a "<code>new VerificationsInOrder() {...}</code>" block must be used
   instead.
   Inside this block, simply write invocations to one or more mocked types in the order they are expected to have occurred.
</p>
<pre><code>@Test
public void verifyingExpectationsInOrder(@Mocked DependencyAbc abc) {
   // Somewhere inside the tested code:
   abc.aMethod();
   abc.doSomething("blah", 123);
   abc.anotherMethod(5);
   ...

   new <strong>VerificationsInOrder</strong>() {{
      // The order of these invocations must be the same as the order
      // of occurrence during replay of the matching invocations.
      <strong>abc.aMethod();
      abc.anotherMethod(<var>anyInt</var>);</strong>
   }};
}
</code></pre>
<p>
   Note that the call <code>abc.doSomething(...)</code> was <em>not</em> verified in the test, so it could have occurred at any time (or
   not at all).
</p>

<h3 id="fullVerification">
   <a href="#fullVerification">Full verification</a>
</h3>
<p>
   Sometimes it may be desired to have <em>all</em> invocations to the mocked types/instances involved in a test verified.
   In such cases, a "<code>new FullVerifications() {...}</code>" block will make sure that no invocations are left unverified.
</p>
<pre><code>@Test
public void verifyAllInvocations(@Mocked Dependency mock) {
   // Code under test included here for easy reference:
   mock.setSomething(123);
   mock.setSomethingElse("anotherValue");
   mock.setSomething(45);
   mock.save();

   <strong>new FullVerifications()</strong> {{
      mock.setSomething(<var>anyInt</var>); // verifies two actual invocations
      mock.setSomethingElse(<var>anyString</var>);
      mock.save(); // if this verification (or any other above) is removed the test will fail
   }};
}
</code></pre>

<h2 id="delegates">
   <a href="#delegates">Delegates: specifying custom results</a>
</h2>
<p>
   We have seen how to record results for invocations through assignments to the <code><var>result</var></code> field or calls to the
   <code>returns(...)</code> method.
   We have also seen how to match invocation arguments flexibly with the <code>withXyz(...)</code> group of methods and the various
   <code><var>anyXyz</var></code> fields.
   But what if a test needs to decide the result of a recorded invocation based on the arguments it will receive at replay time?
   We can do it through a <code class="type">Delegate</code> instance, as exemplified below.
</p>
<pre><code>@Tested CodeUnderTest cut;

@Test
public void delegatingInvocationsToACustomDelegate(@Mocked DependencyAbc anyAbc) {
   new Expectations() {{
      anyAbc.intReturningMethod(<var>anyInt</var>, <var>anyString</var>);
      <var>result</var> = <strong>new Delegate() {
         int aDelegateMethod(int i, String s) {
            return i == 1 ? i : s.length();
         }
      }</strong>;
   }};

   // Calls to "intReturningMethod(int, String)" will execute the delegate method above.
   <var>cut</var>.doSomething();
}
</code></pre>
<p>
   The <code class="type">Delegate</code> interface is empty, being used simply to tell JMockit that actual invocations at replay time
   should be delegated to the "delegate" method in the assigned object.
   This method can have any name, provided it is the only non-<code>private</code> method in the delegate object.
   As for the parameters of the delegate method, they should either match the parameters of the recorded method, or there should be none.
   In any case, the delegate method is allowed to have an additional parameter of type <code class="type">Invocation</code> as its first
   parameter.
   The <code class="type">Invocation</code> object received during replay will provide access to the invoked instance and the actual
   invocation arguments, along with other abilities.
   The return type of a delegate method doesn't have to be the same as the recorded method, although it should be compatible in order to
   avoid a <code class="type">ClassCastException</code> later.
</p>
<p>
   Constructors can also be handled through delegate <em>methods</em>.
   The following example test shows a constructor invocation being delegated to a method which conditionally throws an exception.
</p>
<pre><code>@Test
public void delegatingConstructorInvocations(@Mocked Collaborator anyCollaboratorInstance) {
   new Expectations() {{
      new Collaborator(<var>anyInt</var>);
      <var>result</var> = <strong>new Delegate() {
         void delegate(int i) { if (i < 1) throw new IllegalArgumentException(); }
      }</strong>;
   }};

   // The first instantiation using "Collaborator(int)" will execute the delegate above.
   new Collaborator(4);
}
</code></pre>

<h2 id="withCapture">
   <a href="#withCapture">Capturing invocation arguments for verification</a>
</h2>
<p>
   Invocation arguments can be captured for later verification through a set of special "<code>withCapture(...)</code>" methods.
   There are three different cases, each with its own specific capturing method:
</p>
<ol>
   <li>verification of arguments passed to a mocked method, in a single invocation: <code>T withCapture()</code>;</li>
   <li>verification of arguments passed to a mocked method, in multiple invocations: <code>T withCapture(List&lt;T>)</code>;</li>
   <li>verification of arguments passed to a mocked constructor: <code>List&lt;T> withCapture(T)</code>.</li>
</ol>

<h3 id="singleInvocationCapture">
   <a href="#singleInvocationCapture">Capturing arguments from a single invocation</a>
</h3>
<p>
   To capture arguments from a single invocation to a mocked method or constructor, we use <code>withCapture()</code>,
   as the following example test demonstrates.
</p>
<pre><code>@Test
public void capturingArgumentsFromSingleInvocation(@Mocked Collaborator mock) {
   // Inside tested code:
   ...
   new Collaborator().doSomething(0.5, new int[2], "test");

   // Back in test code:
   new Verifications() {{
      double d;
      String s;
      mock.doSomething(<strong>d = withCapture()</strong>, null, <strong>s = withCapture()</strong>);

      assertTrue(d > 0.0);
      assertTrue(s.length() > 1);
   }};
}
</code></pre>
<p>
   The <code>withCapture()</code> method can only be used in verification blocks.
   Typically, we use it when a <em>single</em> matching invocation is expected to occur; if more than one such invocation occurs, however,
   the last one to occur overwrites the values captured by previous ones.
   It is particularly useful with parameters of a complex type (think a JPA <code class="annotation">@Entity</code>), which may contain
   several items whose values need to be checked.
</p>

<h3 id="multipleInvocationCapture">
   <a href="#multipleInvocationCapture">Capturing arguments from multiple invocations</a>
</h3>
<p>
   If <em>multiple</em> invocations to a mocked method or constructor are expected, and we want to capture values for all of them, then the
   <code>withCapture(List)</code> method should be used instead, as in the example below.
</p>
<pre><code>@Test
public void capturingArgumentsFromMultipleInvocations(@Mocked Collaborator mock) {
   // Inside tested code:
   mock.doSomething(dataObject1);
   mock.doSomething(dataObject2);
   ...

   // Back in test code:
   new Verifications() {{
      List&lt;DataObject> dataObjects = new ArrayList<>();
      mock.doSomething(<strong>withCapture(dataObjects)</strong>);

      assertEquals(2, dataObjects.size());
      DataObject data1 = dataObjects.get(0);
      DataObject data2 = dataObjects.get(1);
      // Perform arbitrary assertions on data1 and data2.
   }};
}
</code></pre>
<p>
   Differently from <code>withCapture()</code>, the <code>withCapture(List)</code> overload can also be used in expectation recording
   blocks.
</p>

<h3 id="capturingNewInstances">
   <a href="#capturingNewInstances">Capturing new instances</a>
</h3>
<p>
   Finally, we can capture the new instances of a mocked class that got created during the test.
</p>
<pre><code>@Test
public void capturingNewInstances(@Mocked Person mockedPerson) {
   // From the code under test:
   dao.create(new Person("Paul", 10));
   dao.create(new Person("Mary", 15));
   dao.create(new Person("Joe", 20));
   ...

   // Back in test code:
   new Verifications() {{
      // Captures the new instances created with a specific constructor.
      List&lt;Person> personsInstantiated = withCapture(new Person(<var>anyString</var>, <var>anyInt</var>));

      // Now captures the instances of the same type passed to a method.
      List&lt;Person> personsCreated = new ArrayList<>();
      dao.create(withCapture(personsCreated));

      // Finally, verifies both lists are the same.
      assertEquals(personsInstantiated, personsCreated);
   }};
}
</code></pre>

<h2 id="cascading">
   <a href="#cascading">Cascading mocks</a>
</h2>
<p>
   When using complex APIs where functionality is distributed through many different objects, it is not uncommon to see chained invocations
   of the form <code>obj1.getObj2(...).getYetAnotherObj().doSomething(...)</code>.
   In such cases it may be necessary to mock all objects/classes in the chain, starting with <code>obj1</code>.
</p>
<p>
   All three mocking annotations provide this ability.
   The following test shows a basic example, using the <code>java.net</code> and <code>java.nio</code> APIs.
</p>
<pre><code>@Test
public void recordAndVerifyExpectationsOnCascadedMocks(
   @Mocked Socket anySocket, // will match any new Socket object created during the test
   @Mocked SocketChannel cascadedChannel // will match cascaded instances
) throws Exception {
   new Expectations() {{
      // Calls to Socket#getChannel() will automatically return a cascaded SocketChannel;
      // such an instance will be the same as the second mock parameter, allowing us to
      // use it for expectations that will match all cascaded channel instances:
      cascadedChannel.isConnected(); <var>result</var> = false;
   }};

   // Inside production code:
   Socket sk = new Socket(); // mocked as "anySocket"
   SocketChannel ch = sk.getChannel(); // mocked as "cascadedChannel"

   if (!ch.isConnected()) {
      SocketAddress sa = new InetSocketAddress("remoteHost", 123);
      ch.connect(sa);
   }

   InetAddress adr1 = sk.getInetAddress();  // returns a newly created InetAddress instance
   InetAddress adr2 = sk.getLocalAddress(); // returns another new instance
   ...

   // Back in test code:
   new Verifications() {{ cascadedChannel.connect((SocketAddress) withNotNull()); }};
}
</code></pre>
<p>
   In the test above, calls to eligible methods in the mocked <code class="type">Socket</code> class will return a <em>cascaded mock</em>
   object whenever they occur during the test.
   The cascaded mock will allow further cascading, so a <code>null</code> reference will never be obtained from methods which return object
   references (except for non-eligible return types <code class="type">Object</code> or <code class="type">String</code> which will return
   <code>null</code>, or collection types which will return a non-mocked empty collection).
</p>
<p>
   Unless there is an available mocked instance from a mock field/parameter (such as <code>cascadedChannel</code> above), a <em>new</em>
   cascaded instance will get created from the first call to each mocked method.
   In the example above, the two different methods with the same <code class="type">InetAddress</code> return type will create and return
   <em>different</em> cascaded instances; the same method will always return the same cascaded instance, though.
</p>
<p>
   New cascaded instances are created with <code class="annotation">@Injectable</code> semantics, so as to not affect other instances of the
   same type that may exist during the test.
</p>
<p>
   Finally, it's worth noting that, if necessary, cascaded instances can be replaced with non-mocked ones, with a different mocked instance,
   or not be returned at all; for that, record an expectation which assigns the <code><var>result</var></code> field with the desired
   instance to be returned, or with <code>null</code> if no such instance is desired.
</p>

<h3 id="staticFactories">
   <a href="#staticFactories">Cascading static factory methods</a>
</h3>
<p>
   Cascading is quite useful in scenarios where a mocked class contains <code>static</code> <em>factory methods</em>.
   In the following example test, lets say we want to mock the <code class="type">javax.faces.context.FacesContext</code> class from JSF
   (Java EE).
</p>
<pre><code>@Test
public void postErrorMessageToUIForInvalidInputFields(@Mocked FacesContext jsf) {
   // Set up invalid inputs, somehow.

   // Code under test which validates input fields from a JSF page, adding
   // error messages to the JSF context in case of validation failures.
   FacesContext ctx = FacesContext.getCurrentInstance();

   if (<em>some input is invalid</em>) {
      ctx.addMessage(null, new FacesMessage("Input xyz is invalid: blah blah..."));
   }
   ...

   // Test code: verify appropriate error message was added to context.
   new Verifications() {{
      FacesMessage msg;
      jsf.addMessage(null, msg = withCapture());
      assertTrue(msg.getSummary().contains("blah blah"));
   }};
}
</code></pre>
<p>
   What's interesting in the test above is that we never have to worry about <code>FacesContext.getCurrentInstance()</code>, as the
   "<code>jsf</code>" mocked instance gets automatically returned.
</p>

<h3 id="fluent">
   <a href="#fluent">Cascading self-returning methods</a>
</h3>
<p>
   Another scenario where cascading tends to help is when code under test uses a
   "<a href="http://martinfowler.com/bliki/FluentInterface.html">fluent interface</a>", where a "builder" object returns itself from most
   of its methods.
   So, we end up with a method call chain which produces some final object or state.
   In the example test below we mock the <code class="type">java.lang.ProcessBuilder</code> class.
</p>
<pre><code>@Test
public void createOSProcessToCopyTempFiles(@Mocked ProcessBuilder pb) throws Exception {
   // Code under test creates a new process to execute an OS-specific command.
   String cmdLine = "copy /Y *.txt D:\\TEMP";
   File wrkDir = new File("C:\\TEMP");
   Process copy = new ProcessBuilder().command(cmdLine).directory(wrkDir).inheritIO().start();
   int exit = copy.waitFor();
   ...

   // Verify the desired process was created with the correct command.
   new Verifications() {{ pb.command(withSubstring("copy")).start(); }};
}
</code></pre>
<P>
   Above, methods <code>command(...)</code>, <code>directory(...)</code>, and <code>inheritIO()</code> configure the process to be created,
   while <code>start()</code> finally creates it.
   The mocked process builder object automatically returns itself ("<code>pb</code>") from these calls, while also returning a new mocked
   <code class="type">Process</code> from the call to <code>start()</code>.
</P>

<h2 id="instanceMatching">
   <a href="#instanceMatching">Matching invocations to specific instances</a>
</h2>
<p>
   Previously, we explained that an expectation recorded on a mocked instance, such as "<code><strong>abc</strong>.someMethod();</code>"
   would actually match invocations to <code>DependencyAbc#someMethod()</code> on <em>any</em> instance of the mocked
   <code class="type">DependencyAbc</code> class.
   In most cases, tested code uses a <em>single</em> instance of a given dependency, so this won't really matter and can be safely ignored,
   whether the mocked instance is <em>passed into</em> the code under test or <em>created inside</em> it.
   But what if we need to verify that invocations occur on a <em>specific</em> instance, between several ones that happen to be used in the
   code under test?
   Also, what if only one or a few instances of the mocked class should actually be mocked, with other instances of the same class
   remaining unmocked?
   (This second case tends to occur more often when classes from the standard Java libraries, or from other third-party libraries, are
   mocked.)
   The API provides a mocking annotation, <code class="annotation">@Injectable</code>, which will only mock <em>one</em> instance of the
   mocked type, leaving others unaffected.
   Additionally, we have a couple ways to constrain the matching of expectations to specific <code class="annotation">@Mocked</code>
   instances, while still mocking <em>all</em> instances of the mocked class.
</p>

<h3 id="injectable">
   <a href="#injectable">Injectable mocked instances</a>
</h3>
<p>
   Suppose we need to test code which works with multiple instances of a given class, some of which we want to mock.
   If an instance to be mocked can be <em>passed</em> or <em>injected</em> into the code under test, then we can declare an
   <code class="annotation">@Injectable</code> mock field or mock parameter for it.
   This <code class="annotation">@Injectable</code> instance will be an "exclusive" mocked instance; any other instance of the same mocked
   type, unless obtained from a separate mock field/parameter, will remain as a regular, non-mocked instance.
</p>
<p>
   When using <code class="annotation">@Injectable</code>, <code>static</code> methods and constructors are also excluded from being mocked.
   After all, a <code>static</code> method is not associated with any instance of the class, while a constructor is only associated with a
   newly created (and therefore different) instance.
</p>
<p>
   For an example, lets say we have the following class to be tested.
</p>
<pre><code>public final class ConcatenatingInputStream extends InputStream
{
   private final Queue&lt;InputStream> sequentialInputs;
   private InputStream currentInput;

   public ConcatenatingInputStream(InputStream... sequentialInputs) {
      this.sequentialInputs = new LinkedList&lt;InputStream>(Arrays.asList(sequentialInputs));
      currentInput = this.sequentialInputs.poll();
   }

   @Override
   public int read() throws IOException {
      if (currentInput == null) return -1;

      int nextByte = currentInput.read();

      if (nextByte >= 0) {
         return nextByte;
      }

      currentInput = sequentialInputs.poll();
      return read();
   }
}
</code></pre>
<p>
   This class could easily be tested without mocking by using <code class="type">ByteArrayInputStream</code> objects for input, but lets say
   we want to make sure that the <code>InputStream#read()</code> method is properly invoked on each input stream passed in the constructor.
   The following test will achieve this.
</p>
<pre><code>@Test
public void concatenateInputStreams(
   @Injectable InputStream input1, @Injectable InputStream input2
) throws Exception {
   new Expectations() {{
      input1.read(); returns(1, 2, -1);
      input2.read(); returns(3, -1);
   }};

   InputStream concatenatedInput = new ConcatenatingInputStream(input1, input2);
   byte[] buf = new byte[3];
   concatenatedInput.read(buf);

   assertArrayEquals(new byte[] {1, 2, 3}, buf);
}
</code></pre>
<p>
   Note that the use of <code class="annotation">@Injectable</code> is indeed necessary here, since the class under test extends the mocked
   class, and the method called to exercise <code class="type">ConcatenatingInputStream</code> is actually defined in the base
   <code class="type">InputStream</code> class.
   If <code class="type">InputStream</code> was mocked "normally", the <code>read(byte[])</code> method would always be mocked, regardless
   of the instance on which it is called.
</p>

<h3 id="multipleMockedInstances">
   <a href="#multipleMockedInstances">Declaring multiple mocked instances</a>
</h3>
<p>
   When using <code class="annotation">@Mocked</code> or <code class="annotation">@Capturing</code> (and not
   <code class="annotation">@Injectable</code> on the same mock field/parameter), we can still match replay invocations to expectations
   recorded on specific mocked instances.
   For that, we simply declare multiple mock fields or parameters of the same mocked type, as the next example shows.
</p>
<pre><code>@Test
public void matchOnMockInstance(
   @Mocked Collaborator <strong>mock</strong>, @Mocked Collaborator <strong>otherInstance</strong>
) {
   new Expectations() {{ mock.getValue(); <var>result</var> = 12; }};

   // Exercise code under test with mocked instance passed from the test:
   int result = <strong>mock</strong>.getValue();
   assertEquals(12, result);

   // If another instance is created inside code under test...
   Collaborator another = new Collaborator();

   // ...we won't get the recorded result, but the default one:
   assertEquals(0, another.getValue());
}
</code></pre>
<p>
   The test above will only pass if the tested code (here embedded in the test method itself, for brevity) invokes <code>getValue()</code>
   on the exact same instance on which the recording invocation was made.
   This is typically useful when the code under test makes calls on two or more different instances of the same type, and the test wants to
   verify that a particular invocation occurred on the expected instance.
</p>

<h3 id="futureInstancesByConstructor">
   <a href="#futureInstancesByConstructor">Instances created with a given constructor</a>
</h3>
<p>
   Specifically for <em>future</em> instances that will later get created by code under test, JMockit provides a couple mechanisms through
   which we can match invocations on them.
   Both mechanisms require the recording of an expectation on a specific <em>constructor invocation</em> (a "<code>new</code>" expression)
   of the mocked class.
</p>
<p>
   The first mechanism involves simply using the new instance obtained from the recorded constructor expectation, when recording
   expectations on instance methods.
   Lets see an example.
</p>
<pre><code>@Test
public void newCollaboratorsWithDifferentBehaviors(@Mocked Collaborator anyCollaborator) {
   // Record different behaviors for each set of instances:
   new Expectations() {{
      // One set, for instances created with "a value":
      Collaborator col1 = new Collaborator("a value");
      col1.doSomething(<var>anyInt</var>); <var>result</var> = 123;

      // Another set, for instances created with "another value":
      Collaborator col2 = new Collaborator("another value");
      col2.doSomething(<var>anyInt</var>); <var>result</var> = new InvalidStateException();
   }};

   // Code under test:
   new Collaborator("a value").doSomething(5); // will return 123
   ...
   new Collaborator("another value").doSomething(0); // will throw the exception
   ...
}
</code></pre>
<p>
   In the above test, we declare a single mock field or mock parameter of the desired class, using <code class="annotation">@Mocked</code>.
   This mock field/parameter, however, is <em>not</em> used when recording expectations; instead, we use the instances created on
   <em>instantiation recordings</em> to record further expectations on instance methods.
   The future instances created with matching constructor invocations will map to those recorded instances.
   Also, note that it's not necessarily a one-to-one mapping, but a many-to-one mapping, from potentially many future instances to a single
   instance used for recorded expectations.
</p>
<p>
   The second mechanism lets us associate a given mock instance with a recorded constructor expectation, and then use this instance for
   recording expectations on instance methods which will match invocations on future instances created with a matching constructor
   invocation.
   With this alternative mechanism, we can rewrite the test as follows.
</p>
<pre><code>@Test
public void newCollaboratorsWithDifferentBehaviors(@Mocked Collaborator col1, @Mocked Collaborator col2) {
   new Expectations() {{
      // Map separate sets of future instances to separate mock parameters:
      new Collaborator("a value"); <var>result</var> = col1;
      new Collaborator("another value"); <var>result</var> = col2;

      // Record different behaviors for each set of instances:
      col1.doSomething(<var>anyInt</var>); <var>result</var> = 123;
      col2.doSomething(<var>anyInt</var>); <var>result</var> = new InvalidStateException();
   }};

   // Code under test:
   new Collaborator("a value").doSomething(5); // will return 123
   ...
   new Collaborator("another value").doSomething(0); // will throw the exception
   ...
}
</code></pre>
<p>
   Both versions of the test are equivalent.
</p>

<h2 id="partial">
   <a href="#partial">Partial mocking</a>
</h2>
<p>
   By default, <em>all</em> methods and constructors which can be called on a mocked type <em>and</em> its super-types (except for
   <code class="annotation">java.lang.Object</code>) get mocked.
   This is appropriate for most tests, but in some situations we might need to <em>select</em> only certain methods or constructors to be
   mocked.
   Methods/constructors not mocked in an otherwise mocked type will execute normally when called.
</p>
<p>
   When a class or object is partially mocked, JMockit decides whether to execute the real implementation of a method or constructor as it
   gets called from the code under test, based on which expectations were recorded and which were not.
   The following example tests will demonstrate it.
</p>
<pre><code>public class PartialMockingTest
{
   static class Collaborator
   {
      final int value;

      Collaborator() { value = -1; }
      Collaborator(int value) { this.value = value; }

      int getValue() { return value; }
      final boolean simpleOperation(int a, String b, Date c) { return true; }
      static void doSomething(boolean b, String s) { throw new IllegalStateException(); }
   }

   @Test
   public void partiallyMockingAClassAndItsInstances() {
      Collaborator anyInstance = new Collaborator();

      new Expectations(<strong>Collaborator.class</strong>) {{
         anyInstance.getValue(); <var>result</var> = 123;
      }};

      // Not mocked, as no constructor expectations were recorded:
      Collaborator c1 = new Collaborator();
      Collaborator c2 = new Collaborator(150);

      // Mocked, as a matching method expectation was recorded:
      assertEquals(123, c1.getValue());
      assertEquals(123, c2.getValue());

      // Not mocked:
      assertTrue(c1.simpleOperation(1, "b", null));
      assertEquals(45, new Collaborator(45).value);
   }

   @Test
   public void partiallyMockingASingleInstance() {
      Collaborator collaborator = new Collaborator(2);

      new Expectations(<strong>collaborator</strong>) {{
         collaborator.getValue(); <var>result</var> = 123;
         collaborator.simpleOperation(1, "", null); <var>result</var> = false;

         // Static methods can be dynamically mocked too.
         Collaborator.doSomething(<var>anyBoolean</var>, "test");
      }};

      // Mocked:
      assertEquals(123, collaborator.getValue());
      assertFalse(collaborator.simpleOperation(1, "", null));
      Collaborator.doSomething(true, "test");

      // Not mocked:
      assertEquals(2, collaborator.value);
      assertEquals(45, new Collaborator(45).getValue());
      assertEquals(-1, new Collaborator().getValue());
   }
}
</code></pre>
<p>
   As shown above, the <code>Expectations(Object...)</code> constructor accepts one or more classes or objects to be partially mocked.
   If a <code>Class</code> object is given, all methods <em>and</em> constructors defined in that class can be mocked, as well as the
   methods and constructors of its super-classes; <em>all</em> instances of the specified class will be regarded as mocked instances.
   If, on the other hand, a regular <em>instance</em> is given, then <em>only</em> methods, not constructors, in the class hierarchy can be
   mocked; even more, only <em>that</em> particular instance will be mocked.
</p>
<p>
   Notice that in these two example tests there is no mock field or mock parameter.
   The partial mocking constructor effectively provides yet another way to specify mocked types.
   It also lets us turn objects stored in <em>local variables</em> into mocked instances.
   Such objects can be created with any amount of state in internal instance fields; they will keep that state when mocked.
</p>
<p>
   It should be noted that, when we request a class or instance to be partially mocked, it can also have invocations <em>verified</em> on
   it, even if the verified methods/constructors were not recorded.
   For example, consider the following test.
</p>
<pre><code>@Test
public void partiallyMockingAnObjectJustForVerifications() {
   Collaborator collaborator = new Collaborator(123);

   new Expectations(collaborator) {};

   // No expectations were recorded, so nothing will be mocked.
   int value = collaborator.getValue(); // value == 123
   collaborator.simpleOperation(45, "testing", new Date());
   ...

   // Unmocked methods can still be verified:
   new Verifications() {{ c1.simpleOperation(<var>anyInt</var>, <var>anyString</var>, (Date) <var>any</var>); }};
}
</code></pre>
<p>
   Finally, a simpler way to apply partial mocking to a tested class is to have a field in the test class annotated as both
   <code class="annotation">@Tested</code> (see <a href="#tested">section below</a>) and <code class="annotation">@Mocked</code>.
   In this case, the tested object is not passed to the <code class="type">Expectations</code> constructor, but we still need to record
   expectations on any methods requiring mocked results.
</p>

<h2 id="capturing">
   <a href="#capturing">Mocking unspecified implementation classes</a>
</h2>
<p>
   Our discussion of this feature will be based on the (contrived) code below.
</p>
<pre><code>public interface Service { int doSomething(); }
final class ServiceImpl implements Service { public int doSomething() { return 1; } }

public final class TestedUnit
{
   private final Service service1 = <strong>new ServiceImpl();</strong>
   private final Service service2 = <strong>new Service() { public int doSomething() { return 2; } };</strong>

   public int businessOperation() {
      return service1.doSomething() + service2.doSomething();
   }
}
</code></pre>
<p>
   The method we want to test, <code>businessOperation()</code>, uses classes that implement a separate interface,
   <code class="type">Service</code>.
   One of these implementations is defined through an anonymous inner class, which is completely inaccessible (except for the use of
   Reflection) from client code.
</p>
<p>
   Given a base type (be it an <code>interface</code>, an <code>abstract</code> class, or any sort of base class), we can write a test
   which only knows about the base type but where all implementing/extending implementation classes get mocked.
   To do so, we declare a "capturing" mocked type which refers only to the known base type.
   Not only will implementation classes already loaded by the JVM get mocked, but also any additional classes that happen to get loaded by
   the JVM during later test execution.
   This ability is activated by the <code class="annotation">@Capturing</code> annotation, which can be applied to mock fields and mock
   parameters, as demonstrated below.
</p>
<pre><code>public final class UnitTest
{
   <strong>@Capturing Service anyService</strong>;

   @Test
   public void mockingImplementationClassesFromAGivenBaseType() {
      new Expectations() {{ anyService.doSomething(); returns(3, 4); }};

      int result = new TestedUnit().businessOperation();

      assertEquals(7, result);
   }
}
</code></pre>
<p>
   In the test above, two return values are specified for the <code>Service#doSomething()</code> method.
   This expectation will match all invocations to this method, regardless of the actual instance on which the invocation occurs,
   <em>and</em> regardless of the actual class implementing the method.
</p>

<div id="bottom" class="navigation">
   <a href="EnterpriseApplications.html"><img src="go-previous.png" title="Previous chapter"></a>
   <a href="Faking.html"><img src="go-next.png" title="Next chapter"></a>
   <a href="../tutorial.html"><img src="go-home.png" title="Contents"></a>
</div>
</body>
</html>
